= A Task Executor GUI
:source-highlighter: rouge

== What is the hype?

Execute your Python functions _not within_, but _as a GUI_ without writing any GUI code.

By decorating your function, it is recognised as a task and a button will be created in the Task GUI.
The parameters of your function will be presented in a panel of input fields of different kinds.
The output of your function will be printed in rich text.

The Task GUI was originally developed to support test operators to quickly execute isolated tasks for an experiment in a lab. We had developed a complex machinery with microservices and scripts that would run from a Python REPL, however, after initial implementation and when going into routine testing in the lab, it turned out that running the scripts from the Python REPL was cumbersome, most of the time a test function was copied from a procedure and executed without changing any parameters. It would be much more convenient for a test operator to execute such script or functions through a dedicated GUI where each button would represent an isolated action to run a specific test. Since we work in a research environment, this sounded as a useful tool in other labs and environments. That's how the `gui-executor` was born.

[#tasks-gui]
== The Tasks GUI

The Tasks GUI is a generic GUI that allows the user to execute standard tasks by clicking the task button and provide the necessary arguments. An example of such a Task GUI is given in the screenshot below. This screenshot is taken as an example and showcase from a project I'm working on. In further sections we will create such a task GUI step by step.

.A example Task GUI used in a real project. This type of GUI is generated from seven short Python modules containing simple functions to perform one specific task.
[[csl-task-gui,Figure 1]]
image::images/csl_ui.png[width=60%,align=center]

The Task GUI is organised in three panels that are arranged vertically in the window. The top panel is the toolbar to control the Jupyter kernel, the panel at the center contains all the task buttons organised by category, the bottom panel is the console where the output and error messages of the tasks will appear.

When you click on a task button, a fourth panel will appear above the console panel. This is the arguments panel where you can specify all arguments required for the task. Default arguments are shown in gray and can be left to use or overwritten to change. The arguments panel of the selected 'Analyse' task for the 'Circle around optical axis' group is shown below.

.The example Task GUI with arguments panel. The arguments panel is automatically generated by the gui-executor from the arguments and type hints of the Python function.
image::images/csl_ui_args.png[width=60%,align=center]

This 'Analyse' task accepts 5 arguments: a list of observation identifiers, the location of the reduced data, an option to save the generated plots in a given output folder, and a flag to make the tasks output more verbose. Since this task will produce plots, we want to execute it as a GUI App. Finally, the 'Close' button hides the arguments panel again and deselects the task button. The 'Run' button executes the task.

In the rest of this document we will explain how such a GUI as above is created and how you can develop your own version for your specific tasks.

=== Installation

The `gui-executor` package can be installed via https://pypi.org[PyPI]. You should preferably install the package inside a virtual environment unless you want it to be available from your global Python installation.

----
$ pip install [--upgrade] gui-executor
----

Use the `--help` option to see the commandline options for the `gui-executor`:

[%nowrap]
----
$ gui-executor --help
usage: gui-executor [-h] [--version] [--verbose] [--cmd-log CMD_LOG] [--module-path MODULE_PATH]
                    [--kernel-name KERNEL_NAME] [--config CONFIG] [--logo LOGO] [--app-name APP_NAME]
                    [--debug] [--single]

options:
  -h, --help            show this help message and exit
  --version, -V         print the gui-executor version number and exit
  --verbose, -v         print verbose information, increased verbosity level with multiple occurrences
  --cmd-log CMD_LOG     location of the command log files
  --module-path MODULE_PATH
                        module path of the Python modules and scripts
  --kernel-name KERNEL_NAME
                        the kernel that will be started by default, python3 if not given
  --config CONFIG       a YAML file that configures the executor
  --logo LOGO           path to logo PNG or SVG file
  --app-name APP_NAME   the name of the GUI app, will go in the window title
  --debug, -d           set debugging mode
  --single              the UI can be started only once (instead of multiple times)
----

=== The package Layout

To build up the Task GUI, we distinguish each task button as a function, several of these functions can be grouped in a Python module (a `.py` file) and all the modules plus additional information needed for the Task GUI is kept in a Python package. The _CSL Operator GUI_ shown in the screenshot above, is located in the package `camtest.csl` and has the following layout:

----
camtest.csl
   ├──────── __init__.py
   ├──────── camera.py
   ├──────── circle.py
   ├──────── hartmann.py
   ├──────── hexapod.py
   ├──────── huber.py
   ├──────── icons
   ├──────── ogse.py
   ├──────── refmodel.py
   └──────── single.py
----

Each of these `.py` files form a group of buttons in the above Task GUI. The `\\__init__.py` file is special, it defines `camtest.csl` as a package, and it also defines the command to start the Task GUI [see section <<init>>]. The `icons` folder contains the graphics for the task buttons and the application icon.

Simply starting the CSL Task GUI from the commandline would be done as follows:

----
$ gui-executor --module-path camtest.csl
----

=== Defining a Task

Let's build our own simple Task GUI and start with the most stated and useless function, _Hello, World!_. We will eventually build a Task GUI with tasks of increasing complexity and guide you through the different steps.

Create a folder `yakkafootnote:['yakka' means 'work' in informal Australian English]` that will be our Task GUI package. In the folder create an empty file `\\__init__.py` and a file named `hello.py`.

----
yakka
   ├──────── __init__.py
   └──────── hello.py
----

The `hello.py` file shall contain the following code:

[source, python]
----
from gui_executor.exec import exec_task

@exec_task(immediate_run=True) <1>
def hello_world():
    print("Hello, World!")
----
<1> Each task button in the Task GUI is actually a function that is decorated with the `@exec_task` decorator.

Make sure you are at the same directory level as the `yakka` folder and then execute the following command from your terminal. That command will start the Task GUI as shown in the screenshot below.

----
PYTHONPATH=. gui-executor --module-path yakka
----

image::images/yakka-01.png[width=50%,align=center]

We see the task appearing in the screenshot above. The task text is blue which means it will run immediately when clicked. The tasks name is the name of the function and the task group name is the name of the `.py` file. The icon is the standard icon used for the task buttons. When you click the task button, the Console shows the following output:

----
----- Running script 'hello_world' in kernel <1>
The code snippet:
 ──────────────────────────────────────────
  response = hello_world()  <2>
 ──────────────────────────────────────────

Hello, World! <3>
----- function 'hello_world' execution finished. <4>

----
What do we see in this output:

<1> The script is run in the kernel, that is the Jupyter kernel which is started when the Task GUI starts up. By default, the 'python3' kernel is used as you can see in the toolbar.
<2> The code snippet that is run is shown between two horizontal lines. We see that the function is called without arguments and the return is catched in the variable `response` (which is `None` since the function doesn't return anything).
<3> The string 'Hello, World!' is printed when the function was executed.
<4> A mark that the function execution has finished.

Let's add another task that takes an argument 'name' as a string with the default value of "John".

[source, python, subs="+quotes"]
----
from gui_executor.exec import exec_task

**UI_MODULE_DISPLAY_NAME = "Hello Tasks"**  <1>

@exec_task(immediate_run=True)
def hello_world():
    print("Hello, World!")

**@exec_task(display_name="Hello...")  <2>
def hello_you(name: str = "John"):  <3>
    print(f"Hello, {name}!")
**

----
1. if the global variable `UI_MODULE_DISPLAY_NAME` is defined, its value will be used as the name of the group of buttons in this module.
2. You can give the task button a proper name instead of the function name.
3. The type hint for the argument and the default value are used in the arguments panel in the GUI.

image:images/yakka-02.png[width=40%,align=left]
image:images/yakka-03.png[width=40%,align=right]

In the screenshot above, you can see the effect of the small changes we made in the `hello.py`. The tasks button group is now called 'Hello Tasks' and the new task we added got the 'Hello...' name instead of the function name. The new task icon has a different color because it is selected. You can also see in the arguments panel that the type hint is picked up and shown in grey and the default name is also filled in grey in the text field. When I put my name there and press the 'Run' button, you can see that the function is called with the proper argument.

// XXXXX: where to describe docstrings and where they show up?

=== The @exec_task decorator

A Task is a function that is decorated with the `@exec_task` decorator. Such a function or task becomes a button in the Task GUI with a default icon. How the task is presented in the Task GUI and how the task is executed depends on the arguments that are passed into the decorator. In this section we will describe these arguments and what their effect is visually and behind the scenes.

The default behaviour is as follows: The function is decorated with `@exec_task()` without any arguments. The task name will be the function name, the task icon will be image:images/script-function.svg[width=20px]. When the task is selected, an arguments panel will be shown with a 'Run' button and the Task icon will look like image:images/script-function-selected.svg[width=20px]. Click on the 'Run' button will execute the task in the selected Jupyter kernel (by default the 'python3' kernel). This is the behaviour that we have seen in the previous sections.

If you check back on <<csl-task-gui>>, you can see that each of the tasks is visualised with a nice icon and a proper task name, most task names are black but there are some blue task names. All these features are the result from optional parameters on the decorator. Let's describe these parameters now in the following paragraphs. Remember all decorator parameters are optional.

`immediate_run`:: When this parameter is set to True, the task name will be blue and when you click the task, it will run immediately without first showing the arguments panel with a 'Run' button. Don't use this option for tasks that take arguments. This option is usually used for tasks that only print information or emergency action that must run as soon as possible.
`description`:: a string with a short description of the function, intended to be used as a tooltip if no docstring is present for the function.
`display_name`:: a string that will be used as the name of the task (at the right of the button). When this parameter is not given, the function name will be used.
`use_kernel, use_gui_app, use_script_app`:: These flags can be used to specify how the task shall be executed. The default is to execute a task in the Jupyter kernel. Other options are (1) a GUI app which will run the function in a separate process that is a Qt application and (2) a script which will run the function as a script in a separate Python interpreter. Use these parameters exclusively, i.e. only one must be present.
`input_request`:: a tuple of strings to recognise input requests from the task. The GUI will scan the task's stdin channel for a match with any of these strings and if a match is found, the GUI will fire a dialog requesting a 'yes / no' answer. See <<input_requests>> for more detailed information.
`icons`:: This is a tuple of two filepaths that locate the icons that shall be used for the button of this task. The first filepath is the icon for the task button and the second filepath is the icon for the task button when the button is selected. The defaults are image:images/script-function.svg[width=20px] and image:images/script-function-selected.svg[width=20px] respectively.
`allow_kernel_interrupt`:: a flag that, when True, allows the GUI to interrupt the kernel and stop any running task before executing this task. Use this parameter carefully, it is intended for tasks that have an emergency action and need to run immediately regardless if a previous task is still running or not.
`capture_response`:: a string or a tuple of strings that represent the variable(s) in which the result of the function shall be captured. See <<capture_response>> for more detailed information.

=== Your functions parameters

So what about passing arguments to the task. Since a task is just a function, you write your function parameters like any other Python function. The Task GUI will interpret your function parameters and create a panel with input fields that match the type of your parameter (in case you used type hints).

Suppose we have a task to capture an image from a camera and save this image into a file in a folder. Such a function could look like the code below. How that looks in the GUI is shown in the TAB next to the code snippet.

[tabs]
======
Code snippet::
+
[source,python]
----
from gui_executor.exec import exec_task

@exec_task()
def capture_image(camera, exposure_time, aperture, filename, location):
    ...
    image = "Captured image not shown for privacy reasons..."

    return image
----

GUI::
+
image::images/func_param_01.png[width=60%,align=center]

======

There are five parameters for the `capture_image` function and one return value. The GUI shows these parameters in the arguments panel below the task button where you can fill in their values before pressing 'Run'. I have already filled the camera name, the exposure time and aperture, but all arguments are of type `str` since no type hint was used in the functions parameter list. There is also a message saying the return values will be captured in the variable `response`. This variable will be overwritten when the function is executed and is accessible from the Jupyter kernel.

For any given simple function, this is the default behaviour. You do not have to provide more information to run such a function from the Task GUI. All arguments will be passed into the function as strings. When you didn't provide a value, `None` will be passed as an argument. In the screenshot above I have already pressed the 'Run' button, and you can see in the output panel what the arguments look like and what their type is.

Now lets add type hints to the parameters of our function. We will use the string type for the camera name and the filename and location, and we will use a float for the exposure time and an integer for the aperture. For the location, we want to provide a default value.

[tabs]
======
Code snippet::
+
[source,python]
----
from gui_executor.exec import exec_task

@exec_task()
def capture_image(
    camera: str, exposure_time: float, aperture: int,
    filename: str, location: str = "~/data/images"
):
    ...  # here the actual capturing of the image is done
    image = f"Captured image from camera '{camera}' with {exposure_time=} and {aperture=}."
    ...  # here any further processing of the image can be done

    return image
----

GUI::
+
image::images/func_param_02.png[width=60%,align=center]

======

If you now have a look at the arguments panel, you will see a lot of small things have changed. Behind the input fields for each parameter there is now the expected type in grey text. The location had a default value which is put as a placeholder in the input text field and there is a small copy icon aligned at the right in that text field. Pressing this icon will copy the default text into the input field and make this text editable. I again already pressed the 'Run' button and you can see in the output console that the type of the exposure_time argument is 'float', and the type of the aperture argument is 'int'. The return string is also printed with the arguments filled in.

But we can do better. For the filename and location, it would be nice if we could open a file selector box and navigate in our directory structure to select these values. We have done that in the following code snippet where the `filename` has type hint '_FileName_' and `location` has type hint '_Directory_'. These are what we call a _TypeVar_ and both are bound to the _Path_ type. The default for `location` now has changed to a Path value instead of a string.

Another change we added was the `capture_response` parameter of the decorator. The return value of the function is no longer captured in the variable `response`, but in the variable `new_image`.

[tabs]
======
Code snippet::
+
[source,python]
----
from pathlib import Path
from gui_executor.exec import exec_task, FileName, Directory

@exec_task(capture_response='new_image')
def capture_image_file_type_hints(
        camera: str, exposure_time: float, aperture: int,
        filename: FileName, location: Directory = Path("~/data/images")
):
    ...  # here the actual capturing of the image is done

    image = (
        f"Captured image from camera '{camera}' with {exposure_time=} and {aperture=}, "
        f"saving it as {filename=} at {location=}."
    )

    ...  # here any further processing of the image can be done

    return image
----

GUI::
+
image::images/func_param_03.png[width=80%,align=center]

======

If you now select the GUI tab above, the changes in the code result in two new icons (image:images/filename.svg[width=20px] and image:images/folder.svg[width=20px]) that replace the type behind the filename and location input fields. If you click these icons, a file selector box will open and allow you to select either a filename or a folder from your local disk. If you look at the code snippet printed in the output console, the filename and location arguments to the function are now of type _PosixPath_.

The change with the added decorator parameter `capture_response` is apparent in the arguments panel where it now says the return values will be captured in 'new_image', but also in the output console you can see that the variable name in which the return value is captured is `new_image`. So, this function will now, when it is executed, make the return value available in the kernel as the variable named `new_image`.

Lets go one step further and change the type of the camera name. We have only a limited number of camera's around the house and we don't like to type their name all the time, so, we are going to create a dropdown list (or ComboBox) where we can select the camera we want to capture. Luckely, we do not have to worry about coding this dropdown menu, the Task GUI understands the type hint `Enum` and will automatically create a dropdown box for this parameter. In the following code snippet, we have created a `CameraName` enumeration class and use it as a type hint for the camera parameter.

[tabs]
======
Code snippet::
+
[source,python]
----
from pathlib import Path
from enum import IntEnum
from gui_executor.exec import exec_task, FileName, Directory

class CameraName(IntEnum):
    FRONT_DOOR = 1
    BACK_DOOR = 2
    GARDEN = 3
    GARDEN_HOUSE = 4
    BIRD_HOUSE_1 = 5
    BIRD_HOUSE_2 = 6

@exec_task(capture_response='new_image')
def capture_image_camera_name(
        camera: CameraName, exposure_time: float, aperture: int,
        filename: FileName, location: Directory = Path("~/data/images")
):
    ...  # here the actual capturing of the image is done

    image = (
        f"Captured image from camera '{camera.name}' with {exposure_time=} and {aperture=}, "
        f"saving it as {filename=} at {location=}."
    )

    ...  # here any further processing of the image can be done

    return image
----

GUI::
+
image::images/func_param_04.png[width=80%,align=center]

======

In the GUI, you can see that the input field for the `camera` parameter is now a dropdown list. I selected the GARDEN camera already. In the output console, the argument for the function is `CameraName.GARDEN`, and in the f-string that creates the return value, we have to use `camera.name` because that `camera` variable is now an Enum object.


=== Type Hints and Defaults

The following type hints are supported and

* supported type hints
* defining a new type hint
* ListList
* Callback

[#capture_response]
=== Capture the result

Since the task that is executed by the GUI is in fact a simple function, it can also return results. These results are normally captured in a variable `response` which is overwritten by new values each time a task is executed from the GUI, even if the task doesn't return anything explicitly in which case `response` will be None.

The developer of the task can decide to capture the result of a task in a different variable or set of variables. This can be specified in the decorator parameter `capture_response` which can be a string or a tuple of strings. See an example below. The task `generate_model` returns three values of which we only need the 'model' and the 'hexhw'. In the `capture_response` you see that the second unused return value is captured in the `\_` and therefore ignored. If you need to ignore more return values, the `*_` is a valid choice.

----
@exec_task(capture_response=("model", "_", "hexhw"))
def generate_model():
    model = "This is a model"
    s = "an unused return value..."
    hexhw = "this is a reference to a hardware device"
    return model, s, hexhw
----

Notice that the `capture_response` represents what you would actually write in your Python script when calling the function directly.
----
>>> model, _, hexhw = generate_model()
----

WARNING: Be careful when you use this parameter because it will overwrite the variables that you specify when they already exist in the kernel. The intend of this parameter is to be able to work with the response of a task in a more natural way and have tasks use return variables that are agreed in the project. The danger is that if not used carefully, data can be lost.


=== Choosing your icons

TBW

* PNG or SVG
* normal and selected
* what when `immediate_run=True`

=== The Jupyter Kernels

TBW

* Switching kernels and why
* creating a new kernel

=== Running your tasks

TBW

* Running in the kernel
* Running as a script
* Running as a GUI App

[#input_requests]
=== Requesting input

TBW

[#init]
=== The \\__init__.py file

TBW

* creating a function to start the GUI in the background
* add the command to the `setup.py`

== Best Practices
